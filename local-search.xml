<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>balabala</title>
    <link href="/2023/01/20/balabala/"/>
    <url>/2023/01/20/balabala/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>搞个易用的博客真麻烦</title>
    <link href="/2022/01/20/%E6%90%9E%E4%B8%AA%E6%98%93%E7%94%A8%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%9C%9F%E9%BA%BB%E7%83%A6/"/>
    <url>/2022/01/20/%E6%90%9E%E4%B8%AA%E6%98%93%E7%94%A8%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%9C%9F%E9%BA%BB%E7%83%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="搞个易用的博客真麻烦"><a href="#搞个易用的博客真麻烦" class="headerlink" title="搞个易用的博客真麻烦"></a>搞个易用的博客真麻烦</h1><a id="more"></a><p>已经忘了当初怎么搞的Hexo了</p><p>已经忘了自己的环境部署在哪个位置了</p><p>已经一年没正经想过拍照了</p><p>没有内容没有产出</p><p>搞个p的博客！</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前后端分离项目【4】</title>
    <link href="/2021/09/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E3%80%904%E3%80%91/"/>
    <url>/2021/09/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E3%80%904%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="vuex自动登录与重构优化"><a href="#vuex自动登录与重构优化" class="headerlink" title="vuex自动登录与重构优化"></a>vuex自动登录与重构优化</h1><a id="more"></a><h2 id="一、vuex概念"><a href="#一、vuex概念" class="headerlink" title="一、vuex概念"></a>一、vuex概念</h2><ul><li><p><strong>不准确概括：</strong>一个为Vue设计的全局变量增强插件</p></li><li><p><strong>目的：</strong></p><ul><li>管理共享状态，优化多个组件共享状态时的数据流</li><li>不用疯狂传参，不用同步拷贝</li><li>适用于登陆信息这种全局参数</li></ul></li><li><p><strong>做法：</strong></p><ul><li>集中式存储 + 变化控制规则</li><li>把组件的共享状态抽取出来，以一个全局单例模式管理。在项目的任意地方都可以随时获取和动态的修改，在修改后，vue会为你的整个项目做更新</li></ul></li><li><p><strong>优劣：</strong></p><ul><li>小型项目使用 Vuex 可能是繁琐冗余的，通常一个简单的 store 模式就足够使用了</li><li>中大型单页应用会更高效，需要权衡长短期收益</li><li>Flux 架构就像眼镜：您自会知道什么时候需要它</li></ul></li><li><p><strong>Vuex交互图：</strong></p></li></ul><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.1/source/img/WebsocketChatroom/img13.jpg" style="zoom: 33%;" /></p><h2 id="二、留白填空-动态渲染"><a href="#二、留白填空-动态渲染" class="headerlink" title="二、留白填空 动态渲染"></a>二、留白填空 动态渲染</h2><ul><li>确定头像与昵称位置，留出空白<ul><li>img标签写入图片路径，span标签写入昵称文本，基本美化</li><li>数据需要动态渲染进标签，不可能手动写入</li></ul></li></ul><ul><li>获取vuex的state信息，动态填空<ul><li>/store/index.js 中配置vuex state</li><li>挂载state到app mounted生命周期中，标签在展示前先去state取数据</li><li>数据的变化控制独立于Vue，由vuex负责，Vue只协调提供展示位</li><li>不止前后端分离，渲染/控制/展示组件也分离</li><li>可变全局参数，更解耦，也更安全</li></ul></li></ul><ul><li><p>可以动态填空了，填什么？</p><ul><li>不直接读写操作全局变量本身</li><li>页面commit调用某个vuex mutations方法</li><li>该mutations方法，维护对应state状态</li></ul></li><li><p>更灵活的填入和渲染？</p><ul><li>mounted，只在网页展示前一刻渲染，太死板</li><li>computed，计算什么时候需要渲染更新，很灵活</li><li>示例：</li><li>最初：从state读取信息，渲染到网页留白，网页第一次展示给用户</li></ul><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.1/source/img/WebsocketChatroom/img14.jpg" style="zoom: 50%;" /></p><ul><li>点击：调用mutations方法，更改state信息，重新渲染，网页留白更新展示</li></ul><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.1/source/img/WebsocketChatroom/img15.jpg" style="zoom:50%;" /></p><ul><li>图片：不再是展示前一刻填入，computed对象渲染时访问后端资源的绝对路径</li></ul></li></ul><h2 id="三、全局变量-自动登录"><a href="#三、全局变量-自动登录" class="headerlink" title="三、全局变量 自动登录"></a>三、全局变量 自动登录</h2><ul><li><p>vuex action部分</p><ul><li>把点击登录的逻辑，放到vuex中，自动调用，自动利用token</li><li>选mounted生命周期挂载actions方法，刷新时自动让actions响应方法处理全局变量</li><li>响应方法：传入token和具体处理方法</li><li>具体处理：axios异步获取token，commit传递给mutations转变方法</li><li>转变方法：更改全局变量state</li><li>其实就是流程图:</li></ul><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.1/source/img/WebsocketChatroom/img13.jpg" style="zoom: 25%;" /></p></li></ul><ul><li>后端路由和ajax请求处理<ul><li>一系列基本跳转：控制器api_url，视图api.userInfo，模型Token</li><li>Token表内查找token项唯一对应user</li><li>userInfo表内查找user项唯一对应belong</li><li>数据处理，打包返回</li><li>图片应该请求 “后端绝对路径前缀” + “对应头像名称”</li></ul></li></ul><ul><li><p>报错一</p><ul><li><p>405 (Method Not Allowed):</p></li><li><p>源自前后端get post方法不匹配，axios配置输错没能使用post方法</p></li></ul></li><li><p>报错二</p><ul><li>登录时404，初始头像资源路径出错</li><li><strong>原因：</strong>标签地址自动追加后端绝对路径前缀，与state默认值重复</li><li><strong>效果：</strong>自动登录时会覆盖默认state，不影响实际效果，但是不合理，漏洞大</li><li><strong>解决：</strong>后端路径不该直接写入HTML，会造成直接发送get请求不可控。应在后端api视图给出资源地址时就拼接好。</li></ul></li><li><p>报错三</p><ul><li>AttributeError: ‘QuerySet’ object has no attribute ‘user’:</li><li>在Token表查询字段时报错，但表内肯定有user字段</li><li><strong>原因：</strong>方法使用错误，用<strong>get</strong>(key=token).user，而不是<strong>filter</strong>(key=token).user</li><li><strong>解释：</strong>filter返回的是一个列表，内部只有token值，当然没有对应的Token.user</li></ul><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.1/source/img/WebsocketChatroom/img16.jpg" style="zoom:50%;"/></p><ul><li><strong>解决1：</strong>filter抓出列表，再从列表提取token值，再进行查找，纯属脱了裤子放屁</li><li><strong>解决2：</strong>直接去原表用get查</li></ul></li></ul><h2 id="四、路由守卫-重构单页"><a href="#四、路由守卫-重构单页" class="headerlink" title="四、路由守卫 重构单页"></a>四、路由守卫 重构单页</h2><ul><li><p>前端分离的单页应用也有路由系统</p><ul><li><p>App.vue全部复制到新建的视图Chat.vue</p></li><li><p>App.vue中只用<router-view>标签挂载</p></li><li><p>访问根目录时，路由到Chat.vue视图</p></li><li><p>这就是Vue框架MVVM模式的表现形式</p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.1/source/img/WebsocketChatroom/img21.jpg" style="zoom: 33%;" />    </li></ul></li><li><p>vue-router 路由守卫</p><ul><li><strong>作用：</strong>植入、异步、导航控制</li><li><strong>作用域：</strong>全局 / 单个路由独享 / 组件级</li><li><strong>生命周期：</strong>进入 / 更新 / 离开</li></ul></li><li><p>路由守卫优化自动登录</p><ul><li>刷新登录不合理，应该是访问域名时登录</li><li>会更安全，通过守卫前什么都没加载没读取</li><li>组件内beforeRouteEnter时,组件实例还没创建，不！能！使！用！this！</li><li>之前mounted和访问store全是用的this，要想新办法</li><li>独享级守卫，解耦，合理</li></ul></li></ul><ul><li><p>强制自动登录方法与路由守卫同步    </p><ul><li><strong>前端报错</strong>：</li></ul><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.1/source/img/WebsocketChatroom/img17.jpg" style="zoom: 33%;" /></p><ul><li><p><strong>后端报错：</strong>Token matching query does not exist.</p></li><li><p><strong>原因：</strong>token会过期，首次进入也还没填写账户密码，自动登录必定会500报错</p></li><li><p><strong>解决：</strong>用一个布尔标识，判断进入路由时有无自动登录的前提</p></li><li><p><strong>实现：</strong>自动登录和路由守卫同步，等到判断标识再说</p></li><li><p>axios箭头函数内判断有无token，取到有长度用户名true，取到空字段为false</p></li><li><p>async登录方法 + await通信请求</p></li><li><p>vuex actions自动登录方法转为同步</p></li><li><p>路由守卫  强制等待异步请求  再调用自动登录方法的命令</p></li><li><p>即：先检查可不可以调用，再路由守卫</p></li><li><p>此时，没有token整个页面都不加载，仍不完整</p></li></ul></li></ul><ul><li>报错一：<ul><li>路由进去时并不能自动登录，手动点击功能正常</li><li>还是要把autoLogin放到mounted内</li></ul></li></ul><h2 id="五、序列复用-重构后端"><a href="#五、序列复用-重构后端" class="headerlink" title="五、序列复用 重构后端"></a>五、序列复用 重构后端</h2><ul><li>REST framework<ul><li>**@api_view( )**，基于函数视图，路由到一个函数，面向过程，函数式编程</li><li><strong>class APIview</strong>，基于类的视图，路由到一个类，面向对象，</li><li>创建UserinfoCtrl类，用户信息控制器</li><li>api_url中，.as_view( )路由到UserinfoCtrl类视图</li></ul></li></ul><ul><li>UserinfoCtrl控制类<ul><li>定义增删改查 get post等方法</li><li>post时判断有无token，没有则返回前端默认资源</li><li>判断后的操作过于冗余重复，可以复用</li></ul></li></ul><ul><li><p>序列化器与复用</p><ul><li><strong>起因：</strong>每次读写都指定各数据项很烦</li><li><strong>导包：</strong>创建serializers.py文件，针对userInfo表编写序列化器</li><li><strong>结果：</strong>快速生成JSON，不用每次都手动给Response( )返回项赋值了</li><li><strong>适配性更改：</strong></li><li>序列化器的目的是高效处理多个值，期待的<strong>输入</strong>是一个包含多用户信息的字典</li><li>上一步处理用户信息时，不再get而是<strong>filter</strong>出一个字典，直接交给序列化器</li><li>返回项的变化：有token返回序列化字典内对应项，无token返回手写默认项</li><li>图片资源地址后端拼接方式不再有效，改为前端全局变量拼接axios返回的相对路径</li><li>不太完美，默认资源又去后端取了，从前端取更好，但影响不大</li><li>不太完美，前端默认项不能集成到序列化器吗</li></ul></li><li><p>首次登陆后手动刷新才能获取头像</p><ul><li>自动登录放在路由守卫后</li><li>登陆界面进入时已经执行过一次路由守卫自动登录判断了，无token返回的是默认头像</li><li><strong>解决一：</strong></li><li>有token后，JS控制整个页面自动刷新</li><li>但单页应用自动刷新不是合理设计。重新加载代价大，刷新时网不好卡住怎么办？</li><li><strong>解决二：</strong></li><li>watch监听vuex全局变量值，有token后调用方法</li><li>App.vue中，computed取，watch监测token变化情况，有变化则调用自动登录</li><li>相当于，为自动登录方法增加了更轻量更合理的入口</li></ul></li></ul><ul><li>至此，只要页面缓存有token，就会自动处理为登录状态</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li><p>vuex操作</p><ul><li><p>状态 state：<em>this</em>.$store.<strong>state</strong>.userinfo</p></li><li><p>转变 mutations：this.$store.<strong>commit</strong>(“saveUserinfo”,userInfo)</p></li><li><p>响应 actions：<em>this</em>.$store.<strong>dispatch</strong>(“helpAutologin”, localStorage.getItem(“token”))</p></li></ul></li><li><p>框架 + 函数 + 缓存 + 显示控制 = 大前端</p></li></ul><ul><li><p>Vue框架的革命性</p><ul><li><p>data统一存储数据，methods书写方法，vue实例还具有生命周期</p></li><li><p>用框架来操控整个HTML，给每个单页都包裹了一层框架实例</p></li><li><p>这个实例，把前端开发从面向过程，变成了面向对象</p></li><li><p>对实例的操纵，映射到html的变化上，只需要把实例当成对象来编程</p></li><li><p>映射关系和顺序是框架源码考虑的事</p></li></ul></li><li><p>单页应用少自动刷新</p></li><li><p>使用了vue框架，加载了大量JS代码，就要切实发挥好作用</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前后端分离项目【3】</title>
    <link href="/2021/09/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E3%80%903%E3%80%91/"/>
    <url>/2021/09/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E3%80%903%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="异步通信与用户数据鉴权"><a href="#异步通信与用户数据鉴权" class="headerlink" title="异步通信与用户数据鉴权"></a>异步通信与用户数据鉴权</h1><a id="more"></a><h2 id="一、后端配置"><a href="#一、后端配置" class="headerlink" title="一、后端配置"></a>一、后端配置</h2><ul><li>基本异步<ul><li>async - await：已有函数转为异步模式</li><li>去除调试用函数async_to_sync</li></ul></li></ul><ul><li>用户系统鉴权机制<ul><li>Django自带使用cookie+session</li><li>前后端分离使用token + jwt</li><li>Django自带用户组管理。manage.py创建超级用户、可以备份迁移数据库</li><li>Navicat 链接SQLite数据库，可以查看后端session</li><li>浏览器F12调试，可以查看前端cookie</li></ul></li></ul><ul><li><p>自定义API路由</p><ul><li><p>从 urls—&gt; views—&gt; function 到 url—&gt; api_url—&gt; api_view—&gt; function</p></li><li><p>myapp下新建api_url文件，相当于二级路由跳转，所有api_02下的路由都路由到此文件</p></li><li><p>myapp下新建api文件，专门用来写@api_view，区别于普通urls跳转到view</p></li><li><p>include方式导包实现url到api_url的跳转</p></li><li><p>装饰器增加POST接口</p></li></ul></li><li><p>踩坑：</p><ul><li>忘了开redis后台，debug报错很多，仔细一看发现问题在redis端口后解决</li></ul></li></ul><h2 id="二、前端配置"><a href="#二、前端配置" class="headerlink" title="二、前端配置"></a>二、前端配置</h2><p>填写表单—验证—令牌</p><ul><li><p>基本登陆界面</p><ul><li><p>创建Vue组件文件，由JavaScript命名为LoginBox，挂载引用到APP.vue中</p></li><li><p>和APP一样，每个组件只有一个div</p></li><li><p>写一个全网页的固定位置透明黑蒙版，scoped style只作用于当前文件，</p></li><li><p>写一个好看的登陆横幅</p></li></ul></li><li><p>创建登陆表单</p><ul><li>v-model和@click绑定输入框和按钮</li><li>利用axios创建点击函数，post方法传数据给后端接口</li></ul></li></ul><ul><li>美化登陆弹窗:<ul><li>vue开发依赖安装sweetalert，自定义命名导包为“swal”。生态内也有很多其他的，自选。</li><li>swal是第三方函数，并不能像原生alert一样阻塞程序。登陆框会在弹出时消失，不符合设计</li><li>异步swal函数，then内判断alert点击后隐藏登陆界面</li><li>完善swal按钮，区分点击任意位置/按钮的行为</li></ul></li></ul><ul><li>踩坑：<ul><li>无法安装开发依赖，淘宝源又问题？</li><li>结果是梯子和网络和npm冲突，换环境重启解决</li></ul></li></ul><h2 id="三、鉴权登陆"><a href="#三、鉴权登陆" class="headerlink" title="三、鉴权登陆"></a>三、鉴权登陆</h2><h3 id="概念结构"><a href="#概念结构" class="headerlink" title="概念结构"></a>概念结构</h3><ul><li><p>MVVM与MTV：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.1/source/img/WebsocketChatroom/img10.jpg" style="zoom:50%;" /></p></li></ul><ul><li><p>Token：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.1/source/img/WebsocketChatroom/img11.jpg" style="zoom:50%;" />    </p><p>​    </p></li><li><p>基本通信方式：</p><ul><li>后端return Request( )，调用rest_framework向前端发送</li><li>前端用json向后端发送，调用axios快速创建和整理</li></ul></li></ul><h3 id="前–-gt-后–-gt-库"><a href="#前–-gt-后–-gt-库" class="headerlink" title="前–&gt;后–&gt;库"></a>前–&gt;后–&gt;库</h3><ul><li>当前状态：<ul><li>前端发送账户密码表单，后端接收后回复“ok”，前端接收到res内的“ok”</li><li>后端从POST接收到的字典为空，没能正确读取前端表单</li></ul></li></ul><ul><li>前端整理发送data数据：<ul><li>vue-cli 中安装整理数据的qs依赖包，LoginBox组件中导入</li><li>用Qs.stringily( )整理axios传递的data项，JS对象成功转为标准Json</li><li>后端从POST接收到字典正常</li></ul></li></ul><ul><li><p>后端用户验证</p><ul><li><p>不用傻傻地自己写了，不必也不能，直接使用Django的哈希密码校验</p></li><li><p>filter( )从Django自带用户表中搜索对应用户名</p></li><li><p>check_password( )比对用户名对应密码的哈希值</p></li><li><p>写出if-else判断出口，返回不同状态码给前端</p></li></ul></li></ul><h3 id="库–-gt-后–-gt-前"><a href="#库–-gt-后–-gt-前" class="headerlink" title="库–&gt;后–&gt;前"></a>库–&gt;后–&gt;前</h3><ul><li>库创建token表<ul><li>rest_framework.authtoken 组件导入到Settings</li><li>rest_framework.authtoken.modles 组件导入到api</li><li>python manage.py migration合并authtoken的表到数据库</li><li>此时Django后台会有Token表存在，和User表有映射关系（细节不表</li><li>进入后台可以手动添加Token记录</li></ul></li></ul><ul><li>后端返回Token<ul><li>根据用户名，更新/创建/获取token记录</li><li>token表是&lt;key, user&gt;形式</li><li>key就是加密的token令牌，发送给前端</li></ul></li></ul><ul><li>前端保存Token<ul><li>刷新页面时vue.js的生命周期会重启，唯一能利用的是缓存/Cookie</li><li>判断到达出口后，从res中接收token，setitem到缓存</li><li>v-if更改登录图层的显示/关闭</li></ul></li></ul><h2 id="四、新建数据表"><a href="#四、新建数据表" class="headerlink" title="四、新建数据表"></a>四、新建数据表</h2><ul><li><p>自建模型，继承自Django model.Model</p><ul><li><p>安装pillow处理头像图片数据</p></li><li><p>设置数据项，设置缺省值，创建自增int函数</p></li><li><p>makemigration + migrate迁移到SQLite</p></li></ul></li><li><p>链接自建模型生成的userInfo表 / 框架自带auth_user</p><ul><li>OneToOneFiled( )，CASCADE级联绑定auth_user表，删除原表内容时，自建表也删除</li><li>Navicat可以连接到数据库查看各项详细</li></ul></li></ul><ul><li>填充数据<ul><li>在admin中注册自建的model，可以在Django后台页面看到自建数据库model</li><li>此时可以后台手动添加用户信息</li><li>belong项可以关联到User表中的某个用户</li><li>avatar会关联到upload，是因为settings内设置的上传目录是upload</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前后端分离项目【2】</title>
    <link href="/2021/08/04/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E3%80%902%E3%80%91/"/>
    <url>/2021/08/04/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E3%80%902%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="websocket配置与同步通信"><a href="#websocket配置与同步通信" class="headerlink" title="websocket配置与同步通信"></a>websocket配置与同步通信</h1><a id="more"></a><h2 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h2><p><strong>版本：</strong>暂用channels3.0、redis6.2.4、channels-redis3.3、</p><p><strong>链接类型：</strong></p><ul><li><p>浏览器主动请求：DNS解析、HTTP短链接</p><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.0/source/img/WebsocketChatroom/img1.jpg" alt="img1" style="zoom: 67%;" /></p></li><li><p>服务器主动推送：websocket长链接</p><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.0/source/img/WebsocketChatroom/img2.jpg" alt="img2" style="zoom: 50%;" /></p></li></ul><p><strong>WSGI与ASGI：</strong></p><ul><li><p>WSGI（Python Web Server Gateway Interface）网络服务器网关接口</p><p>ASGI（Asynchronous Server Gateway Interface）异步服务器网关接口</p></li><li><p>WSGI基于HTTP协议模式开发，不支持websocket。ASGI补充了当前web开发中一些新的协议标准，支持原有模式和Websocket扩展。即，ASGI是WSGI的扩展.</p></li></ul><h2 id="二、前端配置"><a href="#二、前端配置" class="headerlink" title="二、前端配置"></a>二、前端配置</h2><ul><li><p>主体：</p><ul><li><p>主体盒布局，文本框flex布局</p></li><li><p>分为logo、message、input三个区域</p></li></ul></li><li><p>消息记录和滚动条：</p><ul><li>v-for循环创建message类气泡， :key绑定为消息列表序号</li><li>v-for循环次数由消息列表长度决定</li><li>气泡换行样式：fit-content，word-breal，word-wrap，white-space</li><li>滚动窗口样式：overflow-y</li></ul></li></ul><p>​        <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.0/source/img/WebsocketChatroom/img8.jpg" alt="img8" style="zoom: 33%;" /></p><ul><li><p>前端WS</p><ul><li>前端构建WS实例，用浏览器自带WebSocket()方法，类似HTTP协议 ws://</li><li>将建立的WS实例所需方法指向自己写的对应开/关/收/发函数</li></ul></li><li><p>监听输入框，绑定发送按钮点击事件</p><ul><li>v-model监听输入框、@click</li><li>点击事件将输入框内容推入消息列表，清空已发送输入框</li></ul></li></ul><h2 id="三、后端配置"><a href="#三、后端配置" class="headerlink" title="三、后端配置"></a>三、后端配置</h2><ul><li><p>安装异步插件</p><ul><li>安装channels，挂载到Django_APPS</li><li>配置Django设置和asgi文件，具体参考channels官方文档</li><li>原有配置能对接上前端，完成</li></ul></li><li><p>为channels接管配置路由</p><ul><li>创建独立于Django原有MVT模式的文件用来写WS，并和原有MVT文件关联</li><li>HTTP路由跳转：asgi –&gt; get_wsgi_application –&gt; 交给channels</li><li>WS路由跳转： asgi –&gt; middleWare –&gt; 交给channels子类：routing –&gt; consumers.chatConsumer</li></ul></li><li><p>创建consumers.py代替views.py</p><ul><li><p>后端myapp下创建“consumers.py”文件，用来写API view，不放在views.py区别于http，便于管理。</p></li><li><p>创建一个类来继承导入的channels.WebsocketConsumer对象</p></li><li><p>为这个类添加自己的 链接/断开/接收 的方法函数</p></li></ul></li><li><p>创建routing.py代替urls.py</p><ul><li>为asgi添加ws路由：指向自己写的routing路由，导入URLrouter等必要的组件</li><li>routing指向自己写的consumers视图：内有处理ws的类，re_path代表正则路径写法</li><li>chatConsumer类处理ws：链接/断开/接收对应前端编写的ws方法</li></ul></li></ul><h2 id="四、前后交互"><a href="#四、前后交互" class="headerlink" title="四、前后交互"></a>四、前后交互</h2><ul><li><p>再看一次交互逻辑图，前后端将消息转为自己的格式后处理，发送时再转成标准JSON格式</p><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.0/source/img/WebsocketChatroom/img2.jpg" alt="img2" style="zoom:50%;" /></p></li></ul><ul><li><p>前端打开发送：</p><ul><li><p>函数接口只接触自建方法，而不是直接调用实例</p></li><li><p>打开链接以后立即调用发送方法，发送一条消息</p></li><li><p>发送方法接收msg参数，用JSON.stringify转为标准JSON格式，交给ws实例自带的send方法</p></li></ul></li><li><p>后端接收回复：</p><ul><li>导入的json模块提取文本转为字典</li><li>检测前端发送前是否转JSON成功</li><li>提取字典中的message字段</li><li>把提取出的字段填到标准json中发送</li></ul></li></ul><ul><li>前端接收：<ul><li>onMessage方法接收服务器字符串，用JSON.parse方法转为JavaScript对象</li></ul></li></ul><h2 id="五、聊天功能"><a href="#五、聊天功能" class="headerlink" title="五、聊天功能"></a>五、聊天功能</h2><ul><li><p>从脱机到C2S：消息展示的更新</p><ul><li><p>规范联机通信格式，点击发送后交给sendMessage方法</p></li><li><p>发送给后端，后端全局广播中转后返回</p></li><li><p>接收到前端，JSON.parse().message提取所需字段，推入消息列表后展示到窗口</p></li><li><p>此时状态如下图：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.0/source/img/WebsocketChatroom/img6.jpg" alt="img6" style="zoom:50%;" /></p></li></ul></li></ul><ul><li><p>从C2S到C2C：通道层、用户组、缓存数据的读取使用</p><ul><li><p>本机brew安装Redis并启动服务端，虚拟环境安装channels-redis</p></li><li><p>参考channels配置路由：后端的routing和consumer进行正则匹配，路由到不同的房间和通道层用户组。此时不同IP仍不能通信，因为发送的消息还留在缓存里</p></li><li><p>后端整理消息，读取缓存键值对并广播给用户组，用户组收取信息发给各前端：<br>channels框架定义了监听方法，会根据type值调用同名方法，这个同名方法便可实现推送消息到前端</p></li><li><p>此时状态如下图：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.0/source/img/WebsocketChatroom/img7.jpg" alt="img7" style="zoom: 67%;" /></p></li></ul></li><li><p>至此，同步通信模式的聊天室搭建完毕</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前后端分离项目【1】</title>
    <link href="/2021/07/26/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E3%80%901%E3%80%91/"/>
    <url>/2021/07/26/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E3%80%901%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="环境搭建与基本配置"><a href="#环境搭建与基本配置" class="headerlink" title="环境搭建与基本配置"></a>环境搭建与基本配置</h1><a id="more"></a><h3 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h3><p><strong>关键词</strong>：</p><ul><li>前后端分离，虚拟环境，Django，Vue，VScode，MVT，MVVM</li></ul><p><strong>目的</strong>：</p><ul><li><p>使用虚拟环境/工作区/版本控制等方式，维护本机良好的工程环境</p></li><li><p>对前后端分离&amp;协作的体系和流程建立清晰认识</p></li><li><p>为自己后续的开发建立参考文档和日志记录</p></li></ul><p><strong>版本</strong>：</p><p>python_3.8， Django_3.1， Node_16.5， vue/cli_4.5</p><p><strong>结构</strong>：</p><ul><li><p>前后端均在wrapper虚拟环境下运行，与本地环境无关</p></li><li><p>Vue的前端分离是单页的，挂载在app标签下：书写页面不会刷新跳转浏览器</p></li><li><p>不用Django的MVT模式，不写HTML。前端用Vue的MVVM</p><p>​    <img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V3.0/source/img/WebsocketChatroom/img3.jpg" alt="img3" style="zoom: 33%;" /></p></li></ul><h3 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h3><h4 id="1、后端环境安装"><a href="#1、后端环境安装" class="headerlink" title="1、后端环境安装"></a>1、后端环境安装</h4><p><strong>目的：</strong>python + pip + Django</p><ul><li><p>安装虚拟环境envs</p></li><li><p>pip安装Django</p></li><li><p>Django-admin创建项目和app</p></li><li><p>app添加到项目的settings.py，挂载关联</p></li><li><p>可以通过manage.py开始运行服务器，可指定端口，ctrl+c退出，ctrl+z挂起。</p></li></ul><h4 id="2、后端接口配置"><a href="#2、后端接口配置" class="headerlink" title="2、后端接口配置"></a>2、后端接口配置</h4><h5 id="数据资源"><a href="#数据资源" class="headerlink" title="数据资源"></a>数据资源</h5><p><strong>目的：</strong>传递json数据的API</p><ul><li>安装挂载Django生态内的：rest_framework库</li><li>编写MTV view视图（即MVC controller）：如何处理数据返回json的方法</li><li>编写url：导入app里的views视图模版，将localhost/api_01写入路由，使其成为可访问接口</li></ul><h5 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h5><p><strong>目的：</strong>访问文件夹和图片文件的API</p><ul><li>settings里，改用Path解决相对路径问题，使其指向项目而不是系统内绝对地址<br> 用户访问视角media_url，文件存放位置media_root = BASE_DIR</li><li> urls里，导入settings，导入静态路由制作方法（官方文档有）</li><li> 成功为Django设置了url跳转，url使用settings传入的相对路径</li></ul><p><strong>一些坑：</strong></p><ul><li>项目文件夹创建在虚拟环境下，又直接拖进vscode，导致路径和解释器使用错误，不能正确导入虚拟环境目录下的包。重建后解决。</li><li>指定相对路径后无法直接访问8000根目录，因为此时还没写首页，没有路由。</li></ul><h4 id="3、前端环境安装"><a href="#3、前端环境安装" class="headerlink" title="3、前端环境安装"></a>3、前端环境安装</h4><p><strong>目的：</strong>Node.js + npm + vue</p><ul><li><p>在虚拟环境中安装node.js确保版本隔离，使用nodeenv联结到virtualenv，具体操作参考nodeenv主页。</p></li><li><p>安装cnpm和vuecli</p><p>cnpm的一些安装细节参考：<a href="https://blog.csdn.net/qq_35868412/article/details/103868337">https://blog.csdn.net/qq_35868412/article/details/103868337</a></p></li><li><p>vue ui 创建项目文件夹，用npm管理，default Vue3</p></li><li><p>安装 页面路由管理插件vue-router，全局状态管理插件vuex，在node_modules文件夹中</p></li><li><p>可以开始编辑App.vue页面</p></li></ul><p><strong>一些坑：</strong></p><ul><li><p>虚拟环境nodeenv操作报错：</p><p>urllib.error.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1108)&gt;</p><p>解决：</p><p>参考官方文档在虚拟环境装nodeenv，本地环境安装certifi，重启虚拟环境，再进入虚拟环境后可以部署node</p><figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> pip install certifi</span><br><span class="hljs-meta">$</span><span class="bash"> python3 -m certifi</span><br>/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/certifi/cacert.pem<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /Library/Frameworks/Python.framework/Versions/3.8/etc/openssl/</span><br><span class="hljs-meta">$</span><span class="bash"> ln -s /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/certifi/cacert.pem cert.pem</span><br></code></pre></div></td></tr></table></figure></li><li><p>既然webpack管理下的node会在项目下创建环境和依赖，虚拟环境的收益还明显吗？只能说增加冗余维护秩序吧。</p></li></ul><h4 id="4、前端接口配置"><a href="#4、前端接口配置" class="headerlink" title="4、前端接口配置"></a>4、前端接口配置</h4><ul><li>运行Vue在8000端口，运行Django在9000端口</li><li>编辑APP.vue页面样式，引用9000端口下图片位置</li><li>成功用前端对接展示后端数据</li></ul><p><strong>一些疑问：</strong></p><ul><li>运行两个shell两个服务两个端口：端口与shell与进程/线程的关系？</li><li>HTML内直接填写后端地址就能访问图片：如何路由另一端口？因为都在localhost？Vue的功能？具体通信方式？</li></ul><h3 id="三、跨域与绑定"><a href="#三、跨域与绑定" class="headerlink" title="三、跨域与绑定"></a>三、跨域与绑定</h3><p>目的：前后端分离以后，使用JavaScript的AJAX请求异步获取JSON数据，不必再使用HTTP请求头每次都刷新页面</p><h4 id="1、访问API路由"><a href="#1、访问API路由" class="headerlink" title="1、访问API路由"></a>1、访问API路由</h4><ul><li>安装axios库：vue控制台安装开发依赖，node_module内会出现</li><li>引用axios库：使用axios函数高效创建AJAX请求，get方法获取服务器文件，生命周期为mounted</li><li>结果：确实会访问服务器相应端口，但提示 “拦截远程跨源请求CORS“</li></ul><h4 id="2、CORS"><a href="#2、CORS" class="headerlink" title="2、CORS"></a>2、CORS</h4><ul><li>全称“跨源资源共享”。出于安全性原因，不是同一网域/协议/端口的请求会受限制，避免别人的前端访问。具体标准略。</li><li>安装django-cors-headers到服务器</li><li>挂载和设置，参考pypi社区django-cors-headers文档</li><li>允许前端接口和域名访问、允许多种请求方式、允许多种请求头</li></ul><h4 id="3、绑定"><a href="#3、绑定" class="headerlink" title="3、绑定"></a>3、绑定</h4><ul><li>后端返回的res内有数据，前端读取所需数据</li><li>将数据存入变量，渲染时调用改变页面，即变量绑定</li><li>JS和HTML渲染传递的细节由框架和语言实现</li></ul><h4 id="4、升级为Vue3语法"><a href="#4、升级为Vue3语法" class="headerlink" title="4、升级为Vue3语法"></a>4、升级为Vue3语法</h4><ul><li>补丁式更新，配置型option API → 组合型composition API，组合在一起更方便构建车轮</li><li>option API：data、mounted、methods都要自己编写和传入对象</li><li>composition API：<ul><li>setup函数，执行周期先于所有VUE生命周期，其return可以用于页面绑定</li><li>function方法，也可以返回给页面绑定，而不像vue2的data只返回data</li><li>const常量，导入ref方法可构建为响应式字符串</li><li>return时，test常量当然语法报错，需要用test.value代理调用</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「形状」</title>
    <link href="/2021/02/21/%E3%80%8C%E5%BD%A2%E7%8A%B6%E3%80%8D/"/>
    <url>/2021/02/21/%E3%80%8C%E5%BD%A2%E7%8A%B6%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="「形状」"><a href="#「形状」" class="headerlink" title="「形状」"></a>「形状」</h1><p>一些没有具体意义的影像</p><a id="more"></a><h2 id="无实义"><a href="#无实义" class="headerlink" title="无实义"></a>无实义</h2><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-0.JPG" alt="无实义-0"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-00.JPG" alt="无实义-00：车"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-00%EF%BC%9F.JPG" alt="无实义-00?：车"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-000.JPG" alt="无实义-000：天"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-1.JPG" alt="无实义-1"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-2.JPG" alt="无实义-2：夜"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-3.JPG" alt="无实义-3：水"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-4.JPG" alt="无实义-4：水"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-5.JPG" alt="无实义-5：水"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-6.jpg" alt="无实义-6：水"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-7.JPG" alt="无实义-7：自拍"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-8.JPG" alt="无实义-8：自拍"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/2/%E6%97%A0%E5%AE%9E%E4%B9%89-9.jpg" alt="无实义-9：天"></p>]]></content>
    
    
    <categories>
      
      <category>摄影</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「旧的」</title>
    <link href="/2021/02/21/%E3%80%8C%E6%97%A7%E7%9A%84%E3%80%8D/"/>
    <url>/2021/02/21/%E3%80%8C%E6%97%A7%E7%9A%84%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="「旧的」"><a href="#「旧的」" class="headerlink" title="「旧的」"></a>「旧的」</h1><p>大多是黑白胶卷拍摄的街景与人物</p><a id="more"></a><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>回忆自2016以来从各类老旧事物上捕捉到的光线，通过非线性地拼贴不同时期拍摄的作品完成对老旧事物的审视，思考自身可能沦落的模样与时间流过的意义。</p><blockquote><p>大多数时候只是因为老人不会反抗</p></blockquote><p>即使是这个流媒体肆虐的时代，举起相机从某种程度上依旧是是一种颇具侵略性的行为。当这种行为作为一个学生记录和表达的媒介时，总会笼罩着一种难以察觉的距离感。而老年群体对于这种个体空间及隐私的侵略行为总是慢一拍甚至毫无反应。可能是年岁太高反应变慢，可能是对后生突兀行为的善意包容，也可能是被生活阉割后失去了维护体面的欲望。但总的结果是：我眼中老旧的人事物是很少反抗的。</p><blockquote><p>老相机的节奏得以同步</p></blockquote><p>手动对焦、机械调节、装卷过片：日常使用胶片相机可能是一种有趣的生活方式，但胶卷可怜的解析力和无法磨皮修图的特质决定了它永远不会是一种高效的影像解决方案，特别是对于纯机械纯手动机器而言，仪式感的背后是对抓拍的无奈与技术不娴熟的辛酸。<br>但幸运的是：老旧的大多是不被需要的，独处的时候是好的。仔细取景是不被打扰的，慢慢设置是不担心错过的。我也许是不喜欢快节奏的。</p><blockquote><p>垃圾桶，小摊贩，老年人：</p></blockquote><p>一定要脏乱差，一定要黑白高对比，一定要35mm。<br>别问，问就是人文大师。<br>老法师就好这一口（</p><h2 id="街景"><a href="#街景" class="headerlink" title="街景"></a>街景</h2><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E8%A1%97%E6%99%AF-1.JPG" alt="街景-1"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E8%A1%97%E6%99%AF-2.JPG" alt="街景-2"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E8%A1%97%E6%99%AF-3.JPG" alt="街景-3"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E8%A1%97%E6%99%AF-4.JPG" alt="街景-4"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E8%A1%97%E6%99%AF-5.JPG" alt="街景-5"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E8%A1%97%E6%99%AF-6.JPG" alt="街景-6"></p><h2 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h2><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E4%BA%BA%E7%89%A9-1.JPG" alt="人物-1"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E4%BA%BA%E7%89%A9-2.JPG" alt="人物-2"></p><p><img src="D:\0.repository\blogCDN\source\photo\1\人物-3.JPG" alt="人物-3"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E4%BA%BA%E7%89%A9-4.JPG" alt="人物-4"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E4%BA%BA%E7%89%A9-5.JPG" alt="人物-5"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E4%BA%BA%E7%89%A9-6.JPG" alt="人物-6"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E4%BA%BA%E7%89%A9-7.JPG" alt="人物-7"></p><h2 id="摊贩"><a href="#摊贩" class="headerlink" title="摊贩"></a>摊贩</h2><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E6%91%8A%E8%B4%A9-1.JPG" alt="摊贩-1"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E6%91%8A%E8%B4%A9-2.JPG" alt="摊贩-2"></p><h2 id="静物"><a href="#静物" class="headerlink" title="静物"></a>静物</h2><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E9%9D%99%E7%89%A9-1.JPG" alt="静物-1"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E9%9D%99%E7%89%A9-2.JPG" alt="静物-2"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E9%9D%99%E7%89%A9-3.JPG" alt="静物-3"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E9%9D%99%E7%89%A9-4.JPG" alt="静物-4"></p><h2 id="无题"><a href="#无题" class="headerlink" title="无题"></a>无题</h2><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E6%97%A0%E9%A2%98-1.JPG" alt="无题-1"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E6%97%A0%E9%A2%98-2.JPG" alt="无题-2"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E6%97%A0%E9%A2%98-3.JPG" alt="无题-3"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E6%97%A0%E9%A2%98-4.JPG" alt="无题-4"></p><p><img src="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V2.1/source/photo/1/%E6%97%A0%E9%A2%98-5.JPG" alt="无题-5"></p>]]></content>
    
    
    <categories>
      
      <category>摄影</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记</title>
    <link href="/2021/02/20/JavaScript%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/20/JavaScript%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript笔记"><a href="#JavaScript笔记" class="headerlink" title="JavaScript笔记"></a>JavaScript笔记</h1><a id="more"></a><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><p>Fluid不能在文章开头加目录方便查找就很烦</p><h2 id="2-JavaScript特性"><a href="#2-JavaScript特性" class="headerlink" title="2. JavaScript特性"></a>2. JavaScript特性</h2><ul><li> 一切都是对象</li><li>解析时，结尾会自动追加分号</li><li>函数不传参数不会报错</li><li>ES6 严格检查模式：<br><code>‘use strict’</code>，加在<code>&lt;stript&gt;</code>第一行：<br>定义全局变量则报错，局部变量用 let 定义</li><li></li></ul><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h2><h3 id="3-1-字符串"><a href="#3-1-字符串" class="headerlink" title="3.1 字符串"></a>3.1 字符串</h3><p>可变性：不可赋值<br>字符串：单双引号<br>求长度：str.length<br>转义符： \ </p><p>多行书写：反引号``<br>转为小写：str.toLowerCase( )<br>字符位置：str.indexOf( ‘a~z’ )<br>截取子串：str.substring( 1,3 ) [ )</p><h3 id="3-2-数组"><a href="#3-2-数组" class="headerlink" title="3.2 数组"></a>3.2 数组</h3><p>目的：存取数据           //如何存如何取，方法都可以自己实现<br>内容：可以包含任意数据类型<br>可变：可以赋值，变长补空，变短丢失<br>数字：“1”  不同于  1    </p><p>长度：arr.length<br>切片：arr.slice(1,3) [ )<br>排序：arr.sort( )<br>反转：arr.reverse( )<br>拼接：arr.concat( [1,2,3] )     // 尾接，返回新数组<br>连接：arr.join( ‘ - ‘ )                // 特定字符连接输出</p><p>求索引：indexOf(2)<br>尾进栈：arr.push(‘a’, ‘b’)<br>尾出栈：arr.pop( )<br>头进栈：arr.unshift(‘a’, ‘b’)<br>头出栈：arr.shift( )</p><p>多维数组：arr = [ [1,2], [2,3], [3,4] ]，arr[2][1] = 2</p><h3 id="3-3-对象"><a href="#3-3-对象" class="headerlink" title="3.3 对象"></a>3.3 对象</h3><blockquote><p>特性</p></blockquote><p>对象只有两个东西：属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>name: <span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-comment">// 属性</span><br>age: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">// 方法</span><br>            ......<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>键值对组成，键规定为 ’str‘<br>最后一个属性不加逗号<br>不存在属性不报错<br>可以动态增删属性</p><p>删除属性：delete person.name<br>添加属性：person.new = “2333”<br>有无属性：’toString‘ in person    // True<br>自身属性：hasOwnProperty( ‘name’ )    // True</p><h3 id="3-4-Map-amp-Set"><a href="#3-4-Map-amp-Set" class="headerlink" title="3.4 Map &amp; Set"></a>3.4 Map &amp; Set</h3><p><strong>Map：</strong>字典</p><blockquote><p>get<br>set<br>delete</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([ [<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">100</span>], [<span class="hljs-string">&#x27;Tim&#x27;</span>,<span class="hljs-number">90</span>] ]);<br><span class="hljs-keyword">var</span> name = map.get(<span class="hljs-string">&#x27;Tom&#x27;</span>);<span class="hljs-comment">// 取值</span><br><span class="hljs-built_in">console</span>.log(name); <br>map.set(<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-number">00</span>);<span class="hljs-comment">// 赋值</span><br>map.delete(<span class="hljs-string">&#x27;Tom&#x27;</span>)<span class="hljs-comment">// 删除</span><br></code></pre></div></td></tr></table></figure><p><strong>Set：</strong>无序不重复集合</p><blockquote><p>add<br>has<br>delete</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]);<span class="hljs-comment">// set(2) &#123;3,1&#125;</span><br>set.add(<span class="hljs-number">1</span>)<span class="hljs-comment">// set(2) &#123;3,1&#125;</span><br>set.add(<span class="hljs-number">2</span>)<span class="hljs-comment">// set(3) &#123;3,1,2&#125;</span><br>set.delete(<span class="hljs-number">1</span>)<span class="hljs-comment">// set(2) &#123;3,2&#125;</span><br>set.has(<span class="hljs-number">3</span>)<span class="hljs-comment">// True</span><br></code></pre></div></td></tr></table></figure><h3 id="3-5-流程控制"><a href="#3-5-流程控制" class="headerlink" title="3.5 流程控制"></a>3.5 流程控制</h3><p>同 Java</p><blockquote><p>if判断：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span> (age&lt;<span class="hljs-number">10</span>)&#123; <br>    alert(<span class="hljs-string">&quot;10&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age&lt;<span class="hljs-number">5</span>)&#123;<br>    alert(<span class="hljs-string">&quot;5&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    alert(<span class="hljs-string">&quot;0&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>while循环：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span>(age&lt;<span class="hljs-number">100</span>)&#123;<br>    age = age ++;<br>    <span class="hljs-built_in">console</span>.log(age)<br>&#125;<br><br><span class="hljs-keyword">do</span>&#123;<br>    age = age ++;<br>    <span class="hljs-built_in">console</span>.log(age)    <br>&#125;<span class="hljs-keyword">while</span>(age&lt;<span class="hljs-number">100</span>)<br></code></pre></div></td></tr></table></figure><blockquote><p>for循环：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>for…in循环：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 类似Python</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> age)&#123;<br>    <span class="hljs-built_in">console</span>.log(age[num])<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>forEach循环：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>age.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="3-6-迭代器"><a href="#3-6-迭代器" class="headerlink" title="3.6 迭代器"></a>3.6 迭代器</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// for...in 输出下标 0，1，2</span><br><span class="hljs-comment">// 有漏洞，尽量别用</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> arr)&#123;<br>    <span class="hljs-built_in">console</span>.log(x)<br>&#125;<br><span class="hljs-comment">// for...of 输出具体的值 3，4，5</span><br><span class="hljs-comment">// ES6特性</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">of</span> arr)&#123;<br>    <span class="hljs-built_in">console</span>.log(x)<br>&#125;<br><br><span class="hljs-comment">// map，set，arr 都可以遍历</span><br></code></pre></div></td></tr></table></figure><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><h3 id="4-1-定义函数"><a href="#4-1-定义函数" class="headerlink" title="4.1 定义函数"></a>4.1 定义函数</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 传统函数,直接给abs下定义</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abs</span>(<span class="hljs-params">x</span>)</span>&#123;<br>......<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 匿名函数，结果传给abs，通过abs就可以调用</span><br><span class="hljs-keyword">var</span> abs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>多参数问题：</strong></p><blockquote><p>arguments[ ]：所有传入参数放进一个数组</p></blockquote><blockquote><p>rest参数：获取超出定义参数的所有参数 ，语法： …rest</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AAA</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length&gt;<span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">2</span>; i&lt;<span class="hljs-built_in">arguments</span>.length; i++)&#123;<br>        <span class="hljs-comment">// 总之就是不好用不合理</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BBB</span>(<span class="hljs-params">a, b, ...rest</span>)</span>&#123;<br><span class="hljs-comment">// 传入：1，2，3，4，5，6</span><br>    <span class="hljs-comment">// 结果：a=&gt;1, b=&gt;2, [3,4,5,6]</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-2-变量作用域"><a href="#4-2-变量作用域" class="headerlink" title="4.2 变量作用域"></a>4.2 变量作用域</h3><blockquote><p>特点</p></blockquote><p>JavaScript实际上只有一个全局作用域，函数作用域没找到，就会向外查找，直到window<br><code>alert( )</code> 本身也是一个 <code>window</code> 变量</p><blockquote><p>规范</p></blockquote><p>全局变量都会绑定到window下，需要减少冲突：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 自己申明唯一全局变量</span><br><span class="hljs-keyword">var</span> douglasssy = &#123;&#125;<br><br><span class="hljs-comment">// 自己的代码放入自己定义的唯一空间中</span><br>douglasssy.user = <span class="hljs-string">&#x27;admin&#x27;</span><br>douglasssy.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>申明变量</p></blockquote><p><strong>var</strong> 定义的变量也有作用域：<br>函数：变量仅限内部<br>嵌套：外不见内<br>重名：就近原则<br>提域：变量申明最好放在头部。引擎可以自动将变量申明提到顶部，但不提升赋值代码。</p><p><strong>let</strong> 定义局部变量：</p><p>**const **定义常量 / 抛弃大写字母法</p><h3 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3 方法"></a>4.3 方法</h3><blockquote><p>定义</p></blockquote><p>把函数放在对象里面<br>对象只有两个东西：属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> douglasssy = &#123;<br>    birth: <span class="hljs-number">1998</span>,<span class="hljs-comment">// 属性</span><br>    age: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">// 方法</span><br>        ......<br>&#125;<br>    age： getAge   <span class="hljs-comment">// 也可调用已有函数</span><br>&#125;<br><br><span class="hljs-comment">// 属性</span><br>douglasssy.birth<br>    <br><span class="hljs-comment">// 方法</span><br>douglasssy.age()<br></code></pre></div></td></tr></table></figure><blockquote><p>this</p></blockquote><p>本身无法传递，默认指向调用它的对象</p><blockquote><p>apply</p></blockquote><p>每个函数都有的方法，可以控制 this 指向</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">getAge.apply(douglasssy, []);<span class="hljs-comment">// getAge 内部的 this 被指向了douglasssy，参数为空</span><br></code></pre></div></td></tr></table></figure><h2 id="5-内部对象"><a href="#5-内部对象" class="headerlink" title="5. 内部对象"></a>5. 内部对象</h2><blockquote><p>标准对象</p></blockquote><p>number / string / boolean / object / function / undefined ……</p><h3 id="5-1-date"><a href="#5-1-date" class="headerlink" title="5.1  date"></a>5.1  date</h3><blockquote><p>基础</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br>now.getFullYear();<span class="hljs-comment">// 年</span><br>now.getTime<span class="hljs-comment">// 时间戳：1970.01.01 0:00:00 到现在的毫秒数</span><br></code></pre></div></td></tr></table></figure><blockquote><p>转换</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1578106175991</span>)<span class="hljs-comment">// 时间戳转时间</span><br>now.toLocalString()<span class="hljs-comment">// 调用方法转当地时间</span><br>now.toGMTString()<span class="hljs-comment">// 调用方法转GMT时间</span><br></code></pre></div></td></tr></table></figure><h3 id="5-2-JSON"><a href="#5-2-JSON" class="headerlink" title="5.2 JSON"></a>5.2 JSON</h3><p><strong>XML：</strong>重量级数据交换格式</p><p><strong>BSON：</strong>二进制 JSON，主要用于MongoDB</p><p><strong>JSON：</strong>轻量级数据交换格式，层次结构清晰，人机都易读</p><blockquote><p>格式</p></blockquote><p>任何JS支持的类型都可以用JSON表示</p><ul><li>对象 {}</li><li>数组 []</li><li>键值对 <code>key:value</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象定义</span><br><span class="hljs-keyword">var</span> douglasssy = &#123;<br>    age: <span class="hljs-number">0</span><br>    sex: male<br>&#125;<br><br><span class="hljs-comment">// 对象</span><br><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">age</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><br><span class="hljs-comment">// JSON字符串</span><br><span class="hljs-keyword">var</span> json = <span class="hljs-string">&#x27;&#123;&quot;age&quot;:0,&quot;sex&quot;:&quot;male&quot;&#125;&#x27;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>转化</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象转化JSON</span><br><span class="hljs-built_in">JSON</span>.stringify(douglasssy)<br><br><span class="hljs-comment">// JSON转化对象</span><br><span class="hljs-built_in">JSON</span>.parse(&#123;<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;sex&quot;</span>:<span class="hljs-string">&quot;male&quot;</span>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="5-3-Ajax"><a href="#5-3-Ajax" class="headerlink" title="5.3 Ajax"></a>5.3 Ajax</h3><ul><li><p>Asynchronous JavaScript and XML</p></li><li><p>不是新的编程语言，是一种使用现有标准的新方法</p></li><li><p>不重新加载整个页面的情况下，与服务器交换数据并更新部分网页内容</p></li><li><p>不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行</p></li></ul><ul><li>原生js写法：xhr 异步请求 ( XMLHttpRequest )</li><li>jQuery封装好的方法：<code>$(&quot;#name&quot;).ajax(&quot;&quot;)</code></li><li>axios请求</li></ul><h2 id="6-面向对象编程"><a href="#6-面向对象编程" class="headerlink" title="6. 面向对象编程"></a>6. 面向对象编程</h2><ul><li><p>类：模板</p></li><li><p>对象：具体实例</p></li></ul><h3 id="6-1-proto原型继承"><a href="#6-1-proto原型继承" class="headerlink" title="6.1  proto原型继承"></a>6.1  proto原型继承</h3><p>原型链很复杂，入门不深究，阴间语法不太规范<br>链的尽头都是<code>object</code></p><blockquote><p>定义</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> human = &#123;<br>    name: <span class="hljs-string">&quot;human&quot;</span>,<br>    age: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    name: <span class="hljs-string">&quot;xiaominghg&quot;</span><br>&#125;;<br><br><span class="hljs-comment">// 小明想继承父类，只能以另一个对象为原型，JS运行期间还能乱改...</span><br>xiaoming.__proto__ = human;<br></code></pre></div></td></tr></table></figure><blockquote><p>添加方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个function对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">human</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br><span class="hljs-comment">// 想给human对象添加一个方法，只能在外部用prototype</span><br>human.prototype.hello = <span class="hljs-function"><span class="hljs-keyword">function</span></span>&#123;<br>    alert(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-2-class类继承"><a href="#6-2-class类继承" class="headerlink" title="6.2 class类继承"></a>6.2 class类继承</h3><p>ES6中新增<code>class</code>关键字，类似 Java，更加规范<br>其本质只是一个查看对象原型的语法糖，但就是更先进了</p><blockquote><p>定义</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接定义一个user类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">human</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-comment">// 构造器</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span>&#123;<br>        alert(<span class="hljs-string">&#x27;hello&#x27;</span>)<span class="hljs-comment">// 加方法直接在class里加就好了</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义对象以后不能乱指向，更规范</span><br><span class="hljs-keyword">var</span> xiaoming = <span class="hljs-keyword">new</span> human(<span class="hljs-string">&quot;xiaoming&quot;</span>);<br><span class="hljs-keyword">var</span> douglasssy = <span class="hljs-keyword">new</span> human(<span class="hljs-string">&quot;douglasssy&quot;</span>);<br></code></pre></div></td></tr></table></figure><blockquote><p>继承</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">kid</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">human</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<span class="hljs-comment">// 从父类继承属性要super</span><br>        <span class="hljs-built_in">this</span>.age = age;<span class="hljs-comment">// 自己的属性this</span><br>&#125;<br>    <span class="hljs-function"><span class="hljs-title">byebye</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">// 子类加自己的新方法</span><br>        alert(<span class="hljs-string">&#x27;byebye&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="7-操作BOM对象-★"><a href="#7-操作BOM对象-★" class="headerlink" title="7. 操作BOM对象 ★"></a>7. 操作BOM对象 ★</h2><p><strong>BOM：</strong>浏览器对象模型</p><blockquote><p>window：封装窗口信息</p></blockquote><p>获取高度，大小，边框等<br>全局变量</p><blockquote><p>navigator：封装浏览器信息</p></blockquote><p>获取版本，系统，地理位置等<br>并不可靠</p><blockquote><p>screen： 封装屏幕信息</p></blockquote><p>获取尺寸，分辨率等<br>可以操控电脑实现直播</p><blockquote><p>location：封装URL信息</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">host:<span class="hljs-string">&quot;www.baidu.com&quot;</span><br>href:<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span><br>protocol:<span class="hljs-string">&quot;https:&quot;</span><br>reload:f reload()<span class="hljs-comment">// 刷新网页</span><br>location.assign(<span class="hljs-string">&#x27;url&#x27;</span>)<span class="hljs-comment">// 跳转新url</span><br></code></pre></div></td></tr></table></figure><blockquote><p>document: 当前页面信息</p></blockquote><p>获取HTML DOM具体的文档树节点</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> dl = <span class="hljs-built_in">document</span>.getElementsById(<span class="hljs-string">&#x27;app&#x27;</span>);<span class="hljs-comment">// id选择器</span><br><span class="hljs-keyword">var</span> dl = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;app&#x27;</span>);<span class="hljs-comment">// 类选择器</span><br><span class="hljs-keyword">var</span> dl = <span class="hljs-built_in">document</span>.cookie<span class="hljs-comment">// 获取cookie</span><br><span class="hljs-comment">// 服务器端可以设置cookie：httpOnly提高安全性</span><br></code></pre></div></td></tr></table></figure><blockquote><p>history：页面历史记录</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">history.back()<span class="hljs-comment">// 回退</span><br>history.forward()<span class="hljs-comment">// 前进</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于摄影</title>
    <link href="/2021/02/11/%E5%85%B3%E4%BA%8E%E6%91%84%E5%BD%B1/"/>
    <url>/2021/02/11/%E5%85%B3%E4%BA%8E%E6%91%84%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="对「摄影」分类的一些介绍"><a href="#对「摄影」分类的一些介绍" class="headerlink" title="对「摄影」分类的一些介绍"></a>对「摄影」分类的一些介绍</h1><a id="more"></a><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>督促自己主动思考：如何记录有价值的影像</p><p>每篇博客一个项目，持续性更新</p><p>争取多年后每个项目都是一个优秀的连贯的摄影作品</p><p><del>然后转头就去约plmm拍糖水</del></p>]]></content>
    
    
    <categories>
      
      <category>摄影</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>持续完善博客的功能</title>
    <link href="/2021/02/10/%E6%8C%81%E7%BB%AD%E5%AE%8C%E5%96%84%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <url>/2021/02/10/%E6%8C%81%E7%BB%AD%E5%AE%8C%E5%96%84%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="优化各种问题，后期更换为Timeline？"><a href="#优化各种问题，后期更换为Timeline？" class="headerlink" title="优化各种问题，后期更换为Timeline？"></a>优化各种问题，后期更换为Timeline？</h1><a id="more"></a><h1 id="优化访问速度"><a href="#优化访问速度" class="headerlink" title="优化访问速度"></a>优化访问速度</h1><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>国内直接访问GitHub过慢</p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>使用CDN<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="内容分发网络">[1]</span></a></sup>加速：</p><p>需要新建一个仓库，存入source文件夹内文件，然后发行一个release<br>此时仓库已经镜像到 <a href="https://www.jsdelivr.com/">Jsdlivr</a> ，在博客中使用 <a href="https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V1.0/source/">https://cdn.jsdelivr.net/gh/Douglasssy/blogCDN@V1.0/source/</a> 替换本地资源即可</p><h3 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h3><ul><li><p>可以直接替换根目录吗？每个图片前面都加url，好长好烦</p></li><li><p>对Fluid不熟悉，没有使用CDN加速 JS/CSS 、</p></li></ul><h1 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h1><h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><p>我真的需要分类页吗？<br>应该是需要的，想把技术笔记[^?]与想法废话分割开来。</p><h3 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h3><p>Hexo文档内有添加分类的方法：</p><p>打开主题的分类页开关后<br>直接在<code>Front-matter</code>里添加categories<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="目前只打算分类为 笔记 &amp; 想法">[2]</span></a></sup>分类即可<br><del>真的好简单</del></p><h1 id="添加相册"><a href="#添加相册" class="headerlink" title="添加相册"></a>添加相册</h1><h3 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h3><p>勉强算是个半吊子摄影师，相册功能如何实现？  </p><p>:x: 学习<code>yilia</code>的同步ins图片功能 （不用ins，pass）</p><p>:x: 图片放到<code>source</code>文件夹 （影响解析速度，pass）</p><p>:x: 瀑布流懒加载相册 （只有图库不方便加字）</p><p>⭕ 添加摄影分类，一个博客一个项目，持续性更新</p><h3 id="解决：-2"><a href="#解决：-2" class="headerlink" title="解决："></a>解决：</h3><p>添加摄影分类？</p><p>直接在菜单页添加摄影选项？  </p><p>首页<br>笔记<br>想法<br>摄影<br>归档<br>关于  </p><p>会不会太多了？</p><p>具体实现：</p><p>利用归档功能，为每篇文章设定分类<br>在菜单处引用到<code>categories/photo</code>目录即可分类归档<br><del>一开始还想自己写这功能，简直是睿智</del></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>内容分发网络<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>目前只打算分类为 笔记 &amp; 想法<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo创建的第一篇文章</title>
    <link href="/2021/02/08/%E4%BD%BF%E7%94%A8Hexo%E5%88%9B%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>/2021/02/08/%E4%BD%BF%E7%94%A8Hexo%E5%88%9B%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="测试Markdown语法"><a href="#测试Markdown语法" class="headerlink" title="测试Markdown语法"></a>测试Markdown语法</h1><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用标题时要加 ‘#’ 号  </p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>使用两个回车来换行</p><p>这是第一段</p><p>这是第二段</p><p>换段和换行是不一样的<br>比如现在就是换行<br>两个换行就是换段</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><blockquote><p>使用 ‘&gt;’ 符号开头进行高亮引用</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>使用 [ 名称 ] ( url ) 来创建超链接，比如：<a href="https://www.bilibili.com/">哔哩哔哩</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用 ! [ ] ( ) 来插入图片，效果：</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2974142077,1133506341&fm=26&gp=0.jpg" alt="cyber punk"></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>以 * 开头，效果：</p><ul><li>第一</li><li>第二</li><li>第三</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>‘数字’ + ‘.’ + ‘空格’ 开头，效果：</p><ol><li>第一</li><li>第二</li><li>第三</li></ol><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个或以上的 ‘—‘ 或者 ‘***’ ，效果：</p><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p>使用 ==…== 来高亮，效果：==高亮==</p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>使用 ‘ [ ](title) ’ 来实现标题跳转，效果：<a href="%E6%B5%8B%E8%AF%95Markdown%E8%AF%AD%E6%B3%95">回去！</a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>使用 [toc] 来实现，效果：</p><p>[toc]</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p><del>够用了不箱写了</del><br>Typora牛逼！！！</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
